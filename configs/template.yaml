# ============================================================================
# MASTER CONFIGURATION TEMPLATE - Decentralized Localization
# ============================================================================
# This template contains ALL available configuration options with detailed
# explanations. Copy this file and modify for your specific use case.
#
# Usage: python scripts/run_mps.py --config configs/your_config.yaml
# ============================================================================

# ============================================================================
# NETWORK CONFIGURATION
# ============================================================================
network:
  # Number of sensor nodes to localize (unknown positions)
  # Range: 5-1000+ (limited by memory and computation)
  # Small: 5-20, Medium: 20-50, Large: 50-200, Very Large: 200+
  n_sensors: 30
  
  # Number of anchor nodes (known positions, e.g., GPS-equipped)
  # Minimum: 3 for 2D, 4 for 3D (for unique solution)
  # Recommended: 15-20% of total nodes for good coverage
  n_anchors: 6
  
  # Maximum communication range (fraction of network diameter)
  # Range: 0.1-1.0 (0.1 = sparse, 0.3 = typical, 0.5+ = dense)
  # Lower values = sparser network, harder localization
  communication_range: 0.3
  
  # Spatial dimension (2 for 2D, 3 for 3D localization)
  # Note: 3D requires more anchors and computation
  dimension: 2
  
  # Network area/volume scaling factor (meters)
  # Defines the physical size of the deployment area
  # 2D: area is scale x scale meters
  # 3D: volume is scale x scale x scale meters
  scale: 10.0
  
  # Network topology type (optional, for specific layouts)
  # Options: "random", "grid", "circle", "line"
  # Default: "random"
  topology: "random"
  
  # Minimum connectivity requirement (optional)
  # Ensures each node has at least this many neighbors
  # Range: 2-10 (higher = more robust but less realistic)
  min_connectivity: 3

# ============================================================================
# MEASUREMENT CONFIGURATION
# ============================================================================
measurements:
  # Noise level in distance measurements (multiplicative factor)
  # 0.01 = 1% noise (very accurate, e.g., UWB)
  # 0.05 = 5% noise (typical RF ranging)
  # 0.10 = 10% noise (noisy environment)
  # 0.20 = 20% noise (very challenging)
  noise_factor: 0.05
  
  # Random seed for reproducible results
  # Set to null or omit for random initialization
  seed: 42
  
  # Measurement type
  # Options: "distance" (range-only), "bearing" (angle-only), "both"
  measurement_type: "distance"
  
  # Outlier probability (fraction of corrupted measurements)
  # Range: 0.0-0.2 (0 = no outliers, 0.1 = 10% outliers)
  outlier_probability: 0.0
  
  # Outlier magnitude (multiplicative factor for outliers)
  # Range: 2.0-10.0 (how much worse outliers are)
  outlier_magnitude: 3.0
  
  # Measurement bias (systematic error in meters)
  # Can simulate clock offset effects
  bias: 0.0

# ============================================================================
# ALGORITHM CONFIGURATION
# ============================================================================
algorithm:
  # Algorithm selection
  # Options: "mps", "admm", "both" (for comparison)
  name: "mps"
  
  # --- MPS-specific parameters ---
  
  # Consensus mixing parameter (network diffusion rate)
  # Range: 0.9-0.999
  # Lower (0.9): Faster local updates, may be unstable
  # Higher (0.999): Slower but more stable convergence
  # Recommended: 0.95-0.99 for most networks
  gamma: 0.99
  
  # Proximal step size parameter
  # Range: 0.1-2.0
  # Lower (0.1-0.5): Slow but stable
  # Medium (0.8-1.2): Balanced (recommended)
  # Higher (1.5-2.0): Fast but may oscillate
  alpha: 1.0
  
  # --- ADMM-specific parameters ---
  
  # Penalty parameter (ADMM rho)
  # Range: 0.1-10.0
  # Affects convergence speed and accuracy
  rho: 1.0
  
  # Over-relaxation parameter (ADMM alpha)
  # Range: 1.0-1.8 (1.0 = no relaxation, 1.5-1.8 = typical)
  admm_alpha: 1.5
  
  # --- General convergence parameters ---
  
  # Maximum number of iterations
  # Small networks: 100-300
  # Medium networks: 300-500
  # Large networks: 500-1000+
  max_iterations: 500
  
  # Convergence tolerance (relative change in positions)
  # Range: 1e-6 to 1e-3
  # Tighter = more accurate but slower
  tolerance: 0.00001
  
  # Early stopping patience (iterations without improvement)
  # Set to 0 to disable early stopping
  patience: 50
  
  # Adaptive parameter tuning (experimental)
  # Automatically adjusts alpha/gamma during execution
  adaptive: false
  
  # Warm start from previous solution (for sequential problems)
  warm_start: false

# ============================================================================
# DISTRIBUTED/MPI CONFIGURATION
# ============================================================================
mpi:
  # Enable MPI distributed execution
  # Requires: mpirun -n N python script.py
  enable: false
  
  # Number of MPI processes
  # Should match -n parameter in mpirun
  # Recommended: 2-8 for small clusters, up to #cores available
  n_processes: 4
  
  # Consensus rounds per iteration (for distributed consensus)
  # More rounds = better accuracy but slower
  consensus_rounds: 5
  
  # Asynchronous updates (non-blocking communication)
  # Can be faster but may affect convergence
  async_updates: false
  
  # Load balancing strategy
  # Options: "uniform", "adaptive", "graph-based"
  load_balance: "uniform"

# ============================================================================
# TIME SYNCHRONIZATION (for ranging applications)
# ============================================================================
time_sync:
  # Enable time synchronization simulation
  enable: false
  
  # Clock drift rate (ppm - parts per million)
  # Typical: 10-50 ppm for standard oscillators
  drift_ppm: 20
  
  # Initial clock offset standard deviation (nanoseconds)
  # GPS: ~10ns, NTP: ~1000ns, None: ~1000000ns
  initial_offset_ns: 1000
  
  # Synchronization protocol
  # Options: "twtt" (two-way time transfer), "ntp", "gps", "none"
  protocol: "twtt"
  
  # Synchronization interval (iterations between sync)
  sync_interval: 10

# ============================================================================
# OUTPUT CONFIGURATION
# ============================================================================
output:
  # Save results to file
  save_results: true
  
  # Output directory (created if doesn't exist)
  # Can use patterns: {date}, {time}, {algorithm}, {n_sensors}
  output_dir: "results/{algorithm}_{n_sensors}nodes/"
  
  # Output file format
  # Options: "json", "mat" (MATLAB), "npz" (NumPy), "csv"
  format: "json"
  
  # Verbose logging
  # Options: true/false or 0-3 (0=quiet, 1=normal, 2=verbose, 3=debug)
  verbose: true
  
  # Save intermediate results every N iterations
  # Set to 0 to only save final result
  save_interval: 50
  
  # Save convergence history
  save_history: true
  
  # Save network visualization
  save_plots: true
  
  # Plot format for visualizations
  # Options: "png", "pdf", "svg"
  plot_format: "png"
  
  # Plot resolution (DPI)
  plot_dpi: 150

# ============================================================================
# VISUALIZATION CONFIGURATION
# ============================================================================
visualization:
  # Show plots during execution (requires display)
  show_plots: false
  
  # Update plots during iterations (animated)
  # Warning: Significantly slows down execution
  animate: false
  
  # Animation update interval (iterations)
  animation_interval: 10
  
  # Plot style
  # Options: "default", "paper", "presentation"
  style: "default"
  
  # Color scheme
  # Options: "default", "colorblind", "grayscale"
  colors: "default"
  
  # Node size in plots
  node_size: 50
  
  # Show node labels
  show_labels: true
  
  # Show communication links
  show_links: true
  
  # Show anchor coverage circles
  show_coverage: false

# ============================================================================
# EXPERIMENTAL FEATURES
# ============================================================================
experimental:
  # Enable GPU acceleration (requires CuPy)
  use_gpu: false
  
  # Robust estimation (outlier rejection)
  # Options: "none", "huber", "tukey", "ransac"
  robust_estimator: "none"
  
  # Multi-resolution approach (coarse-to-fine)
  multi_resolution: false
  
  # Number of resolution levels
  resolution_levels: 3
  
  # Belief propagation integration
  use_bp: false
  
  # BP iterations per MPS iteration
  bp_iterations: 10
  
  # Hierarchical processing (for very large networks)
  hierarchical: false
  
  # Cluster size for hierarchical processing
  cluster_size: 50

# ============================================================================
# VALIDATION AND TESTING
# ============================================================================
validation:
  # Compute Cram√©r-Rao Lower Bound (theoretical limit)
  compute_crlb: false
  
  # Compare against ground truth (if available)
  compare_truth: true
  
  # Compute confidence intervals
  confidence_intervals: false
  
  # Confidence level (e.g., 0.95 for 95% CI)
  confidence_level: 0.95
  
  # Monte Carlo runs (for statistical analysis)
  monte_carlo_runs: 1
  
  # Compute performance metrics
  metrics:
    - "rmse"      # Root Mean Square Error
    - "mae"       # Mean Absolute Error  
    - "max_error" # Maximum error
    - "convergence_rate"
    - "efficiency" # vs CRLB

# ============================================================================
# HARDWARE/DEPLOYMENT CONFIGURATION
# ============================================================================
hardware:
  # Simulate hardware constraints
  simulate_hardware: false
  
  # Processing delay per iteration (milliseconds)
  processing_delay_ms: 10
  
  # Communication delay (milliseconds)
  comm_delay_ms: 5
  
  # Packet loss probability
  packet_loss: 0.0
  
  # Maximum memory per node (MB)
  memory_limit_mb: 100
  
  # Battery constraint (iterations before failure)
  battery_life: 10000

# ============================================================================
# NOTES AND BEST PRACTICES
# ============================================================================
# 1. Start with default values and adjust based on results
# 2. For comparison studies, only change one parameter at a time
# 3. Use seed for reproducible results during development
# 4. Increase iterations if not converging
# 5. Decrease alpha/increase gamma if oscillating
# 6. Enable MPI for networks with 50+ sensors
# 7. Save intermediate results for long runs
# 8. Disable visualization for batch processing
# 9. Use adaptive parameters for unknown environments
# 10. Always validate against CRLB when possible