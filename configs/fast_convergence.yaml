# ============================================================================
# FAST CONVERGENCE CONFIGURATION
# ============================================================================
# Purpose: Achieve quickest possible convergence, trading accuracy for speed
# Use Case: Real-time applications with strict latency requirements
#           - Live tracking, online SLAM, edge computing, embedded systems
# Expected Performance:
#   - Runtime: 2-5 seconds (5-10x faster than default)
#   - Relative Error: 0.15-0.25 (acceptable for many applications)
#   - RMSE: ~0.15 meters in unit square
# Trade-offs:
#   - Lower final accuracy due to aggressive parameters
#   - May oscillate or diverge with very noisy measurements
#   - Less robust to outliers and network irregularities
# ============================================================================

# Inherit from default and override for speed
extends: default.yaml

# ----------------------------------------------------------------------------
# NETWORK CONFIGURATION - Standard size for quick processing
# ----------------------------------------------------------------------------
network:
  # Keep standard network size
  # Smaller would be faster but less interesting
  n_sensors: 30
  n_anchors: 6

# ----------------------------------------------------------------------------
# MEASUREMENT CONFIGURATION - Accept standard noise
# ----------------------------------------------------------------------------
measurements:
  # Standard noise level - no need to change
  # Algorithm speed not affected by noise level
  noise_factor: 0.05

# ----------------------------------------------------------------------------
# ALGORITHM CONFIGURATION - Aggressive parameters for speed
# ----------------------------------------------------------------------------
algorithm:
  # Aggressive mixing favors proximal updates
  # γ=0.95 means 95% proximal, 5% consensus
  # Allows large steps but may oscillate
  # Good for initial progress, may struggle near optimum
  gamma: 0.95
  
  # Very large step size for rapid initial descent
  # α=50 is near the stability limit
  # Will make huge progress initially
  # May overshoot and oscillate later
  # Consider adaptive_alpha=true to reduce near convergence
  alpha: 50.0
  
  # Few iterations - rely on aggressive parameters
  # 200 iterations with α=50 can cover a lot of ground
  # May not fully converge but gets reasonable solution
  max_iterations: 200
  
  # Relaxed tolerance - accept approximate solution
  # 1e-3 relative change is "good enough" for tracking
  # Stops when: |f(k+1) - f(k)| / |f(k)| < 0.001
  tolerance: 1e-3
  
  # Aggressive early stopping to save time
  # Stop quickly if progress stalls
  # 20 iterations is very aggressive
  # May stop prematurely but saves time
  early_stopping: true
  early_stopping_window: 20
  
  # Speed optimizations (some experimental)
  # Parallel proximal only works if L matrix is diagonal
  # Usually not the case, but trying anyway for speed
  parallel_proximal: true
  
  # Skip 2-block construction to save setup time
  # May violate W*1=0 constraint but faster
  use_2block: false
  
  # Skip adaptive alpha to avoid overhead
  # Fixed α=50 throughout execution
  adaptive_alpha: false

# ----------------------------------------------------------------------------
# ADMM CONFIGURATION - Minimal inner iterations
# ----------------------------------------------------------------------------
admm:
  # Very few inner iterations - approximate proximal
  # 20 iterations is bare minimum for reasonable proximal
  # Will not fully converge but "close enough"
  # Major speed gain: 5x faster than 100 iterations
  iterations: 20
  
  # Loose tolerance for inner solver
  # 1e-3 is very relaxed but matches outer tolerance
  # Inner solver stops early, saving time
  tolerance: 1e-3
  
  # Large penalty for fast constraint satisfaction
  # ρ=10 forces quick feasibility
  # May hurt objective but achieves constraints fast
  # Good for getting "any" feasible solution quickly
  rho: 10.0
  
  # Still use warm start - always helps
  warm_start: true

# ----------------------------------------------------------------------------
# PERFORMANCE CONFIGURATION - Minimize overhead
# ----------------------------------------------------------------------------
performance:
  # Disable metrics tracking to save computation
  # Every cycle counts in real-time applications
  track_metrics: false
  
  # No logging - reduces I/O overhead
  log_interval: 0
  
  # No checkpoints - save disk I/O
  save_checkpoints: false

# ----------------------------------------------------------------------------
# OUTPUT CONFIGURATION - Minimal output for speed
# ----------------------------------------------------------------------------
output:
  output_dir: "results/fast_convergence/"
  
  # No intermediate saves - reduce I/O
  save_interval: 0
  
  # Only save final positions
  save_positions: true
  
  # Skip metrics to save processing
  save_metrics: false
  
  # No plotting - significant overhead
  plot_results: false
  
  # Minimal console output
  verbose: false